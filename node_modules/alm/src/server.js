"use strict";
/**
 * The location of this file is important as its our main backend entry point
 * It is used by:
 * - our `bin/alm`
 * - extenal users invoking `node <this file>`
 * So don't move it :)
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Load up TypeScript
 */
var byots = require("byots");
var ensureImport = byots;
/** Other imports */
var express = require("express");
var http = require("http");
var https = require("https");
var cookieParser = require("cookie-parser");
var errorCodes_1 = require("./server/errorCodes");
var path = require("path");
var fs = require("fs");
var open = require("open");
var serverStarted = require("./server/serverStarted");
var events_1 = require("./common/events");
var cl = require("./server/commandLine");
var session = require("./server/disk/session");
var chalk = require("chalk");
var utils = require("./common/utils");
var fsu = require("./server/utils/fsu");
var bundlerMaster_1 = require("./server/workers/external/demoReact/bundler/bundlerMaster");
var types = require("./common/types");
// `Where` to statically serve `what`
var staticServing = (_a = {
        '': path.resolve(__dirname, 'public'),
        // Monaco works best with its own loader,
        // We will serve it up from node_modules
        '/vs': utils.getDirectory(fsu.consistentPath(require.resolve('monaco/build/vs/loader'))),
        // Note:
        // - the names of these modules come from the `define` call in the `contribution` file ;)
        // - the path is ofcourse to the contribution file.
        '/vs/language/css': utils.getDirectory(fsu.consistentPath(require.resolve('monaco-css/release/min/monaco.contribution'))),
        '/vs/basic-languages/src': utils.getDirectory(fsu.consistentPath(require.resolve('monaco-languages/release/src/monaco.contribution')))
    },
    /**
     * Live demo
     */
    _a[types.liveDemoMountUrl] = bundlerMaster_1.liveDemoFolder,
    _a);
/**
 * To use official monaco:
 * npm install monaco-editor-core --save-dev
 */
// monacoSourceDir = fsu.travelUpTheDirectoryTreeTillYouFind(__dirname, 'node_modules') + '/monaco-editor-core/dev/vs'; // DEBUG
var clOptions = cl.getOptions();
/** If the cl options favor early exit (e.g. -i) do that */
if (clOptions.init) {
    session.readDiskSessionsFile();
    console.log('[TSCONFIG] Initialized');
    process.exit(0);
}
/** Build server */
if (clOptions.build) {
    var sessionFileContents = session.readDiskSessionsFile();
    var tsconfig = sessionFileContents.relativePathToTsconfig;
    var doBuild = require('./build').doBuild;
    var doBuildTyped = doBuild;
    doBuildTyped(tsconfig);
}
/** Enable HTTPS if all options are passed in */
var useHttps = clOptions.httpskey && clOptions.httpscert;
// Create express app and http|https server
var app = express();
var server = useHttps
    ? https.createServer({ key: fs.readFileSync(clOptions.httpskey), cert: fs.readFileSync(clOptions.httpscert) }, app)
    : http.createServer(app);
// Basic auth
if (clOptions.auth) {
    var basicAuth = require('basic-auth-connect');
    var _b = clOptions.auth.split(':'), user = _b[0], pass = _b[1];
    app.use(basicAuth(user, pass));
}
// Everything uses cookies
app.use(cookieParser());
// Optionally setup a dev time server
var devtime_1 = require("./server/devtime");
devtime_1.setup(app);
// After dev setup forward to static server
Object.keys(staticServing).map(function (where) {
    var what = staticServing[where];
    if (where) {
        app.use(where, express.static(what, {}));
    }
    else {
        app.use(express.static(what, {}));
    }
});
// Setup a socket server
var socketServer_1 = require("./socket/socketServer");
socketServer_1.register(server);
/** Register an image server */
var imgServer_1 = require("./server/imgServer");
imgServer_1.registerImgServerWithExpress(app);
/**
 * Emitted once the server starts listening
 */
exports.listeningAtUrl = new events_1.TypedEvent();
// Start listening
var getPort_1 = require("./server/utils/getPort");
getPort_1.getPort(clOptions.port).then(function (port) {
    /** If the user *did* specify a port and we end up not using it */
    if (clOptions.port !== cl.defaultPort
        && port !== clOptions.port) {
        console.log(chalk.magenta("[WEB] WARNING: Desired port is not available so using port " + port));
    }
    // Also setup in clOptions for future use.
    clOptions.port = port;
    server.listen(port, clOptions.host, function (err) {
        if (err) {
            console.error(err);
            errorCodes_1.exit(errorCodes_1.errorCodes.couldNotListen);
        }
        var host = clOptions.host in { 'localhost': true, '127.0.0.1': true, '0.0.0.0': true } ? 'localhost' : clOptions.host;
        var url = "http://" + host + ":" + port;
        if (clOptions.open) {
            open(url);
        }
        console.log("DASHBOARD:", (clOptions.open) ? "(launched in browser)" : chalk.magenta("(Please open in chrome)"), chalk.green(url));
        exports.listeningAtUrl.emit({ url: url });
        serverStarted.started();
    });
});
/**
 * Notify user of updates
 */
var serverState = require("./serverState");
serverState.addRoute(app);
/** Does not exist when we run from `./node_modules/alm_src` */
if (fs.existsSync(__dirname + '/../package.json')) {
    var pkg = require('../package.json');
    var version = pkg.version;
    var typescriptVersion = pkg.dependencies.typescript;
    console.log("Version: " + version + ", TypeScript version: " + typescriptVersion);
    serverState.setServerState({ version: version, typescriptVersion: typescriptVersion });
    var notifier = require('update-notifier')({
        pkg: pkg,
    });
    notifier.notify({
        defer: false
    });
    if (notifier.update) {
        var update = notifier.update;
        serverState.setServerState({ update: update, version: version, typescriptVersion: typescriptVersion });
    }
}
var _a;
