"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var socketLib_1 = require("./socketLib");
var socketIo = io;
var origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
exports.resolve = Promise.resolve.bind(Promise);
/** This is your main function to launch the client */
function run(config) {
    var client = new Client(config.clientImplementation);
    var server = client.sendAllToSocket(config.serverContract);
    var cast = client.setupAllCast(config.cast);
    var pendingRequestsChanged = new socketLib_1.TypedEvent();
    client.pendingRequestsChanged = function (pending) { return pendingRequestsChanged.emit({ pending: pending }); };
    return { client: client, server: server, cast: cast, pendingRequestsChanged: pendingRequestsChanged, connectionStatusChanged: client.connectionStatusChanged };
}
exports.run = run;
var Client = (function (_super) {
    __extends(Client, _super);
    function Client(clientImplementation) {
        var _this = _super.call(this) || this;
        _this.getSocket = function () { return _this.socket; };
        _this.connectionStatusChanged = new socketLib_1.TypedEvent();
        _this.typedEvents = {};
        _this.socket = io.connect(origin);
        // Also provide the following services to the server
        _this.registerAllFunctionsExportedFromAsResponders(clientImplementation);
        _this.startListening();
        _this.socket.on(socketLib_1.anycastMessageName, function (msg) {
            _this.typedEvents[msg.message].emit(msg.data);
        });
        var connected = false;
        setInterval(function () {
            var newConnected = _this.socket.connected;
            if (newConnected != connected) {
                connected = newConnected;
                _this.connectionStatusChanged.emit({ connected: connected });
            }
        }, 2000);
        return _this;
    }
    /**
     * Each member of `instance` must be a typed event
     * we wire these up to be emitted in the client if an emit is called on the server
     */
    Client.prototype.setupAllCast = function (instance) {
        var _this = this;
        Object.keys(instance).forEach(function (name) {
            // Override the actual emit function with one that sends it on to the server
            _this.typedEvents[name] = instance[name];
        });
        return instance;
    };
    return Client;
}(socketLib_1.RequesterResponder));
exports.Client = Client;
