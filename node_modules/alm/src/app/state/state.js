"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var types = require("../../common/types");
var simpleRedux_1 = require("./simpleRedux");
var utils = require("../../common/utils");
var initialStoreState = {
    activeProject: null,
    errorsExpanded: false,
    errorsDisplayMode: types.ErrorsDisplayMode.all,
    errorsFilter: '',
    activeProjectFilePathTruthTable: {},
    filePathsInActiveProject: [],
    outputStatusCache: {},
    liveBuildResults: {
        builtCount: 0,
        totalCount: 0
    },
    pendingRequests: [],
    findOptions: {
        isShown: false,
        query: '',
        isRegex: false,
        isCaseSensitive: false,
        isFullWord: false
    },
    socketConnected: false,
    filePaths: [],
    filePathsCompleted: false,
    fileTreeShown: false,
    showDoctor: false,
    showSemanticView: false,
    tsWorking: {
        working: false,
    },
    testedWorking: {
        working: false,
    },
};
var redux = new simpleRedux_1.SimpleRedux(initialStoreState);
exports.store = redux.store;
exports.getState = redux.getState;
exports.subscribe = redux.subscribe;
exports.subscribeSub = redux.subscribeSub;
exports.setActiveProject = redux.add('setActiveProject', function (state, payload) {
    return {
        activeProject: payload,
    };
});
exports.inActiveProjectFilePath = function (filePath) { return !!exports.getState().activeProjectFilePathTruthTable[filePath]; };
exports.inActiveProjectUrl = function (url) {
    if (!url)
        return false;
    var protocol = (_a = utils.getFilePathAndProtocolFromUrl(url), _a.protocol), filePath = _a.filePath;
    if (protocol == 'file' || protocol == 'ast' || protocol == 'astfull') {
        return exports.inActiveProjectFilePath(filePath);
    }
    else {
        return true;
    }
    var _a;
};
exports.setFilePathsInActiveProject = redux.add('setActiveProjectFiles', function (state, payload) {
    // Filter out the `.json` files. These are good for `project data loader` but we don't need it in the UI
    payload = payload.filter(function (p) { return !p.endsWith('.json'); });
    var truthTable = utils.createMap(payload);
    /** Also add all the *folders* in any of the files */
    payload.forEach(function (fp) {
        // Basically we go up the file path
        // If at any point its already in the truth table it means that we've already added everything else that is needed.
        var folder = utils.getDirectory(fp);
        while (folder && !truthTable[folder]) {
            truthTable[folder] = true;
            folder = utils.getDirectory(folder);
        }
    });
    return {
        activeProjectFilePathTruthTable: truthTable,
        filePathsInActiveProject: payload,
    };
});
exports.expandErrors = redux.add('expandErrors', function (state, payload) {
    return {
        errorsExpanded: true,
    };
});
exports.collapseErrors = redux.add('collapseErrors', function (state, payload) {
    return {
        errorsExpanded: false,
    };
});
exports.setErrorsDisplayMode = redux.add('setErrorsDisplayMode', function (state, payload) {
    return {
        errorsDisplayMode: payload,
    };
});
exports.setErrorsFilter = redux.add('setErrorsFilter', function (state, payload) {
    return {
        errorsFilter: payload,
    };
});
exports.setPendingRequests = redux.add('setPendingRequests', function (state, payload) {
    return {
        pendingRequests: payload
    };
});
exports.setFindOptionsQuery = redux.add('setFindOptionsQuery', function (state, payload) {
    var findQuery = state.findOptions;
    var newFindQuery = redux.updateFields({ query: payload })(findQuery);
    return {
        findOptions: newFindQuery
    };
});
exports.setFindOptionsIsCaseSensitive = redux.add('setFindOptionsIsCaseSensitive', function (state, payload) {
    var findQuery = state.findOptions;
    var newFindQuery = redux.updateFields({ isCaseSensitive: payload })(findQuery);
    return {
        findOptions: newFindQuery
    };
});
exports.setFindOptionsIsRegex = redux.add('setFindOptionsIsRegex', function (state, payload) {
    var findQuery = state.findOptions;
    var newFindQuery = redux.updateFields({ isRegex: payload })(findQuery);
    return {
        findOptions: newFindQuery
    };
});
exports.setFindOptionsIsFullWord = redux.add('setFindOptionsIsFullWord', function (state, payload) {
    var findQuery = state.findOptions;
    var newFindQuery = redux.updateFields({ isFullWord: payload })(findQuery);
    return {
        findOptions: newFindQuery
    };
});
exports.setFindOptionsIsShown = redux.add('setFindOptionsIsShown', function (state, payload) {
    var findQuery = state.findOptions;
    var newFindQuery = redux.updateFields({ isShown: payload })(findQuery);
    return {
        findOptions: newFindQuery
    };
});
exports.setSocketConnected = redux.add('setSocketConnected', function (state, payload) {
    return {
        socketConnected: payload
    };
});
exports.setFilePaths = redux.add('setFilePaths', function (state, config) {
    return {
        filePaths: config.filePaths,
        rootDir: config.rootDir,
        filePathsCompleted: config.completed
    };
});
exports.expandFileTree = redux.add('expandFileTree', function (state, payload) {
    return {
        fileTreeShown: true,
    };
});
exports.collapseFileTree = redux.add('collapseFileTree', function (state, payload) {
    return {
        fileTreeShown: false,
    };
});
exports.toggleDoctor = redux.add('toggleDoctor', function (state, payload) {
    return {
        showDoctor: !state.showDoctor
    };
});
exports.setShowDoctor = redux.add('setShowDoctor', function (state, payload) {
    return {
        showDoctor: payload
    };
});
exports.toggleSemanticView = redux.add('toggleSemanticView', function (state, payload) {
    return {
        showSemanticView: !state.showSemanticView
    };
});
exports.setShowSemanticView = redux.add('setShowSemanticView', function (state, payload) {
    return {
        showSemanticView: payload
    };
});
exports.fileOuputStatusUpdated = redux.add('fileOuputStatusUpdated', function (state, payload) {
    var outputStatusCache = redux.updateFields((_a = {}, _a[payload.inputFilePath] = payload, _a))(state.outputStatusCache);
    return {
        outputStatusCache: outputStatusCache
    };
    var _a;
});
exports.completeOuputStatusCacheUpdated = redux.add('completeOuputStatusCacheUpdated', function (state, payload) {
    var outputStatusCache = payload;
    return {
        outputStatusCache: outputStatusCache
    };
});
exports.setLiveBuildResults = redux.add('setLiveBuildResults', function (state, payload) {
    return {
        liveBuildResults: payload
    };
});
exports.ifJSStatusWasCurrentThenMoveToOutOfDate = redux.add('ifJSStatusWasCurrentThenMoveToOutOfDate', function (state, payload) {
    var oldState = state.outputStatusCache[payload.inputFilePath];
    // If we didn't think it was up to date then don't care
    if (!oldState || oldState.state !== types.JSOutputState.JSUpToDate) {
        return {};
    }
    // It might be out of date now. So move it there till the backend tells us something different
    var newState = {
        inputFilePath: oldState.inputFilePath,
        outputFilePath: oldState.outputFilePath,
        state: types.JSOutputState.JSOutOfDate
    };
    var outputStatusCache = redux.updateFields((_a = {}, _a[payload.inputFilePath] = newState, _a))(state.outputStatusCache);
    return {
        outputStatusCache: outputStatusCache
    };
    var _a;
});
exports.setTSWorking = redux.add('setTSWorking', function (state, payload) {
    return {
        tsWorking: payload
    };
});
exports.setTestedWorking = redux.add('setTestedWorking', function (state, payload) {
    return {
        testedWorking: payload
    };
});
