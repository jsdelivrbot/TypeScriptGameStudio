"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ui = require("./ui");
var state = require("./state/state");
var commands = require("./commands/commands");
var utils = require("../common/utils");
var appTabsContainer_1 = require("./tabs/v2/appTabsContainer");
var globalErrorCacheClient_1 = require("./globalErrorCacheClient");
commands.gotoNext.on(function () {
    gotoNext();
});
commands.gotoPrevious.on(function () {
    gotoPrevious();
});
var errorsInOpenFiles = { members: [] };
var buildOutput = { members: [] };
var referencesOutput = { members: [] };
var reloadErrorsInOpenFiles = utils.debounce(function () {
    var errorsFlattened = appTabsContainer_1.tabState.errorsByFilePathFiltered().errorsFlattened;
    errorsInOpenFiles.members = errorsFlattened.map(function (x) {
        return { filePath: x.filePath, line: x.from.line, col: x.from.ch };
    });
}, 500);
globalErrorCacheClient_1.errorsCache.errorsDelta.on(reloadErrorsInOpenFiles);
state.subscribeSub(function (state) { return state.errorsDisplayMode; }, reloadErrorsInOpenFiles);
state.subscribeSub(function (state) { return state.errorsFilter; }, reloadErrorsInOpenFiles);
appTabsContainer_1.tabStateChanged.on(reloadErrorsInOpenFiles);
/**
 * Use this to keep the *lastPosition* in error list in sync
 * A bit fugly because there might be multiple errors in the same location but works good enough
 */
function gotoError(error) {
    commands.doOpenOrFocusFile.emit({ filePath: error.filePath, position: error.from });
    errorsInOpenFiles.lastIndex = indexOf(errorsInOpenFiles.members, function (member) {
        return member.filePath == error.filePath && member.line == error.from.line && member.col == error.from.ch;
    });
}
exports.gotoError = gotoError;
/** This *must* always be set */
var activeList = errorsInOpenFiles;
function gotoItemInActiveList(index) {
    var member = activeList.members[index];
    activeList.lastIndex = index;
    commands.doOpenOrFocusFile.emit({ filePath: member.filePath, position: { line: member.line, ch: member.col } });
}
/**
 * Uses `activeList` to go to the next error or loop back
 * Storing `lastIndex` with the list allows us to be lazy elsewhere and actively find the element here
 */
function findCurrentIndexInList() {
    // Early exit if no members
    if (!activeList.members.length) {
        ui.notifyInfoNormalDisappear('No members in active go-to list');
        return -1;
    }
    // If we don't have a lastPosition then first is the last position
    if (!activeList.lastIndex || activeList.lastIndex == -1)
        return 0;
    // If we have gone too far, then goto last
    if (activeList.lastIndex >= activeList.members.length)
        return activeList.members.length - 1;
    // Index is good. Return that :)
    return activeList.lastIndex;
}
/** Uses `activeList` to go to the next position or loop back */
function gotoNext() {
    var currentIndex = findCurrentIndexInList();
    if (currentIndex == -1)
        return;
    var nextIndex = currentIndex + 1;
    // If next is == length then loop to zero
    if (nextIndex == activeList.members.length) {
        nextIndex = 0;
    }
    gotoItemInActiveList(nextIndex);
}
exports.gotoNext = gotoNext;
/** Uses `activeList` to go to the previous position or loop back */
function gotoPrevious() {
    var currentIndex = findCurrentIndexInList();
    if (currentIndex == -1)
        return;
    var previousIndex = currentIndex - 1;
    // If next is == -1 then loop to length
    if (previousIndex == -1) {
        previousIndex = activeList.members.length - 1;
    }
    gotoItemInActiveList(previousIndex);
}
exports.gotoPrevious = gotoPrevious;
/**
 * Utility Return index of element in an array based on a filter
 */
function indexOf(items, filter) {
    for (var i = 0; i < items.length; i++) {
        if (filter(items[i])) {
            return i;
        }
    }
    return -1;
}
