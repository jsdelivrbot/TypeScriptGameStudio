"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Convinient base component and ui utilities
 */
exports.React = require("react");
exports.ReactDOM = require("react-dom");
var events_1 = require("../common/events");
exports.$ = require("jquery");
/** The base component that provides an easy access point for overall app behaviour changes */
var BaseComponent = (function (_super) {
    __extends(BaseComponent, _super);
    function BaseComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.disposible = new events_1.CompositeDisposible();
        _this.isUnmounted = false;
        _this._afterComponentDidUpdateQueue = [];
        _this.getParentDomNode = function () {
            var node = exports.ReactDOM.findDOMNode(_this);
            return node.parentElement;
        };
        return _this;
    }
    BaseComponent.prototype.componentWillUnmount = function () {
        this.disposible.dispose();
        this.isUnmounted = true;
    };
    // Making it easier to deal with refs
    BaseComponent.prototype.ref = function (name) {
        return this.refs[name];
    };
    /**
     * Register stuff to call after component did update
     * Note: For redux-connected component,
     * - call this *before* calling state action
     *   (as its a bit undeterministic and sometimes runs render / didUpdate immediately after calling action)
     */
    BaseComponent.prototype.afterComponentDidUpdate = function (cb) {
        this._afterComponentDidUpdateQueue.push(cb);
    };
    /**
     * You generally want afterComponentDidUpdate.
     */
    BaseComponent.prototype.componentDidUpdate = function () {
        this._afterComponentDidUpdateQueue.forEach(function (cb) { return cb(); });
        this._afterComponentDidUpdateQueue = [];
    };
    return BaseComponent;
}(exports.React.Component));
exports.BaseComponent = BaseComponent;
/**
 * Certain components control when they unmount themselves
 * e.g. Modals
 * This gives a convinient point for this logic
 */
function getUnmountableNode() {
    var node = document.createElement('div');
    var unmount = function () {
        exports.ReactDOM.unmountComponentAtNode(node);
        node.remove();
    };
    return { node: node, unmount: unmount };
}
exports.getUnmountableNode = getUnmountableNode;
/**
 * Toggle component
 * http://instructure-react.github.io/react-toggle/
 */
exports.Toggle = require('react-toggle');
require('react-toggle/style.css');
/**
 * Notifications
 */
var toastr = require("toastr");
require('toastr/build/toastr.css');
function notifyInfoQuickDisappear(message) {
    toastr.info(message, null, { timeOut: 600 });
}
exports.notifyInfoQuickDisappear = notifyInfoQuickDisappear;
function notifyInfoNormalDisappear(message, options) {
    toastr.info(message, null, options && { onclick: options.onClick });
}
exports.notifyInfoNormalDisappear = notifyInfoNormalDisappear;
function notifyWarningNormalDisappear(message, options) {
    toastr.warning(message, null, options && { onclick: options.onClick });
}
exports.notifyWarningNormalDisappear = notifyWarningNormalDisappear;
function notifySuccessNormalDisappear(message, options) {
    toastr.success(message, null, options && { onclick: options.onClick });
}
exports.notifySuccessNormalDisappear = notifySuccessNormalDisappear;
function comingSoon(featureName) {
    toastr.info("Coming soon! : " + featureName);
}
exports.comingSoon = comingSoon;
/**
 * Keyboard handling
 */
/** Utility function for keyboard handling */
function getKeyStates(e) {
    var event = e; // This is a lie .... but a convinient one as react provides the same stuff
    var nativeEvent = e.nativeEvent; // This is the truth
    var tab = event.key == 'Tab';
    var shift = nativeEvent.shiftKey;
    var mod = nativeEvent.metaKey || nativeEvent.ctrlKey;
    var enter = event.key == 'Enter';
    var up = event.key == 'ArrowUp';
    var down = event.key == 'ArrowDown';
    var tabNext = tab && !shift;
    var tabPrevious = tab && shift;
    return { tab: tab, tabNext: tabNext, tabPrevious: tabPrevious, up: up, down: down, shift: shift, mod: mod, enter: enter };
}
exports.getKeyStates = getKeyStates;
exports.DraggableCore = require('react-draggable').DraggableCore;
/**
 * General react utilities
 */
/** Creates whitespace from a 0 based indent */
function indent(indent, tabSize) {
    if (tabSize === void 0) { tabSize = 4; }
    return Array((indent * tabSize) + 1).join().split('').map(function (i) { return "\u00a0"; });
}
exports.indent = indent;
/**
 * General utility for consistent coloring
 */
function kindToColor(kind, lighten) {
    if (lighten === void 0) { lighten = false; }
    var add = lighten ? 50 : 0;
    var opacity = lighten ? 0.2 : 1;
    switch (kind) {
        case ts.ScriptElementKind.keyword:
        case 'snippet':
            // redish
            return "rgba(" + (0xf9 + add) + "," + (0x26 + add) + "," + (0x72 + add) + "," + opacity + ")";
        case ts.ScriptElementKind.scriptElement:
        case ts.ScriptElementKind.moduleElement:
        case ts.ScriptElementKind.classElement:
        case ts.ScriptElementKind.localClassElement:
        case ts.ScriptElementKind.interfaceElement:
        case ts.ScriptElementKind.typeElement:
        case ts.ScriptElementKind.enumElement:
        case ts.ScriptElementKind.alias:
        case ts.ScriptElementKind.typeParameterElement:
        case ts.ScriptElementKind.primitiveType:
            // yelloish
            // #e6db74
            return "rgba(" + (0xe6 + add) + "," + (0xdb + add) + "," + (0x74 + add) + "," + opacity + ")";
        case ts.ScriptElementKind.variableElement:
        case ts.ScriptElementKind.localVariableElement:
        case ts.ScriptElementKind.memberVariableElement:
        case ts.ScriptElementKind.letElement:
        case ts.ScriptElementKind.constElement:
        case ts.ScriptElementKind.label:
        case ts.ScriptElementKind.parameterElement:
        case ts.ScriptElementKind.indexSignatureElement:
            // blueish
            // #66d9ef
            return "rgba(" + (0x66 + add) + "," + (0xd9 + add) + "," + (0xef + add) + "," + opacity + ")";
        case ts.ScriptElementKind.functionElement:
        case ts.ScriptElementKind.localFunctionElement:
        case ts.ScriptElementKind.memberFunctionElement:
        case ts.ScriptElementKind.memberGetAccessorElement:
        case ts.ScriptElementKind.memberSetAccessorElement:
        case ts.ScriptElementKind.callSignatureElement:
        case ts.ScriptElementKind.constructorImplementationElement:
        case 'path':
            // greenish
            // #a6e22e
            return "rgba(" + (0xa6 + add) + "," + (0xe2 + add) + "," + (0x2e + add) + "," + opacity + ")";
        default:
            return "rgba(" + (0xaa + add) + "," + (0xaa + add) + "," + (0xaa + add) + "," + opacity + ")";
    }
}
exports.kindToColor = kindToColor;
/**
 * For consitent icon lookup against kind
 */
var fontAwesomeToCharCode_1 = require("./utils/fontAwesomeToCharCode");
function kindToIcon(kind) {
    switch (kind) {
        case 'snippet':
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.exchange);
        case 'path':
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.fileText);
        case ts.ScriptElementKind.keyword:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.key);
        case ts.ScriptElementKind.classElement:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.copyright);
        case ts.ScriptElementKind.interfaceElement:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.infoCircle);
        case ts.ScriptElementKind.scriptElement:
        case ts.ScriptElementKind.moduleElement:
        case ts.ScriptElementKind.localClassElement:
        case ts.ScriptElementKind.typeElement:
        case ts.ScriptElementKind.enumElement:
        case ts.ScriptElementKind.alias:
        case ts.ScriptElementKind.typeParameterElement:
        case ts.ScriptElementKind.primitiveType:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.archive);
        case ts.ScriptElementKind.variableElement:
        case ts.ScriptElementKind.localVariableElement:
        case ts.ScriptElementKind.memberVariableElement:
        case ts.ScriptElementKind.letElement:
        case ts.ScriptElementKind.constElement:
        case ts.ScriptElementKind.label:
        case ts.ScriptElementKind.parameterElement:
        case ts.ScriptElementKind.indexSignatureElement:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.at);
        case ts.ScriptElementKind.functionElement:
        case ts.ScriptElementKind.localFunctionElement:
        case ts.ScriptElementKind.memberFunctionElement:
        case ts.ScriptElementKind.memberGetAccessorElement:
        case ts.ScriptElementKind.memberSetAccessorElement:
        case ts.ScriptElementKind.callSignatureElement:
        case ts.ScriptElementKind.constructorImplementationElement:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.circleArrowRight);
        default:
            return fontAwesomeToCharCode_1.toFontAwesomeCharCode(fontAwesomeToCharCode_1.FAIconName.info);
    }
}
exports.kindToIcon = kindToIcon;
