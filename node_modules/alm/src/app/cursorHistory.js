"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Singleton that maintains the cursor history
 */
var commands = require("./commands/commands");
var utils = require("../common/utils");
var appTabsContainer_1 = require("./tabs/v2/appTabsContainer");
/** The current cursor location */
var currentIndex = -1;
var history = [];
var tooMany = 200;
/** Subscribe to user requests to move around */
commands.previousCursorLocation.on(function () {
    previous();
});
commands.nextCursorLocation.on(function () {
    next();
});
function previous() {
    currentIndex = utils.rangeLimited({ min: 0, max: history.length - 1, num: currentIndex - 1 });
    var tab = history[currentIndex];
    if (tab) {
        commands.doOpenOrFocusTab.emit({ tabId: tab.tabId, tabUrl: tab.tabUrl, position: tab.position });
    }
    // debug();
}
exports.previous = previous;
function next() {
    currentIndex = utils.rangeLimited({ min: 0, max: history.length - 1, num: currentIndex + 1 });
    var tab = history[currentIndex];
    if (tab) {
        commands.doOpenOrFocusTab.emit({ tabId: tab.tabId, tabUrl: tab.tabUrl, position: tab.position });
    }
    // debug();
}
exports.next = next;
/**
 * The current tab with id is fetched from state. So all you need is editorPosition
 */
exports.addEntry = utils.debounce(function (editorPosition) {
    var selectedTab = appTabsContainer_1.tabState.getSelectedTab();
    /**
     * This can happen if we close the tabs too fast (because this function is debounced)
     * Adding a cursor history should not have been called if there is no active tab
     * Adding a cursor history should not have been called if active tab is not a filePath
     */
    if (!selectedTab || !selectedTab.url.startsWith('file://')) {
        return;
    }
    var potentialNewEntry = {
        tabId: selectedTab.id,
        tabUrl: selectedTab.url,
        position: editorPosition
    };
    var isSame = function (pos1, pos2) { return pos1.line == pos2.line && pos1.ch == pos2.ch; };
    // This prevents us adding a new history for what we already know e.g. when we ask the UI to select a tab
    var testEntry = history[currentIndex];
    if (testEntry && testEntry.tabId == potentialNewEntry.tabId) {
        if (isSame(editorPosition, testEntry.position)) {
            return;
        }
    }
    // if the users action is same as what there would be one before we just take them there in index
    testEntry = history[currentIndex - 1];
    if (testEntry && testEntry.tabId == potentialNewEntry.tabId) {
        if (isSame(editorPosition, testEntry.position)) {
            currentIndex--;
            return;
        }
    }
    // if the users action is same as what there would be one after we just take them there in index
    testEntry = history[currentIndex + 1];
    if (testEntry && testEntry.tabId == potentialNewEntry.tabId) {
        if (isSame(editorPosition, testEntry.position)) {
            currentIndex++;
            return;
        }
    }
    currentIndex++;
    history.splice(currentIndex, 0, potentialNewEntry);
    // If too many:
    if (history.length >= tooMany) {
        // if at end we remove items from the start
        if (currentIndex == history.length - 1) {
            history.shift();
            currentIndex--;
        }
        else {
            history.pop();
        }
    }
    // console.log(`Added tab: ${potentialNewEntry.tabUrl}:${potentialNewEntry.position.line}:${potentialNewEntry.position.ch}`); debug(); // Debug
}, 800);
var debug = function () {
    console.log(history.map(function (h) { return h.tabUrl + ':' + h.position.line + ':' + h.position.ch; }));
    console.log(currentIndex);
};
// window.debug = debug;
