"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mostly providing a typed API on top of `search`
 */
exports.commands = {
    search: function (cm, query) { return startSearch(cm, query); },
    hideSearch: function (cm) { return hideSearch(cm); },
    findNext: function (cm, query) { return findNextIfNotAlreadyDoing(cm, query); },
    findPrevious: function (cm, query) { return findPreviousIfNotAlreadyDoing(cm, query); },
    replaceNext: function (cm, newText) { return simpleReplaceNext(cm, newText); },
    replacePrevious: function (cm, newText) { return simpleReplacePrevious(cm, newText); },
    replaceAll: function (cm, newText) { return simpleReplaceAll(cm, newText); },
};
var startSearch = function (editor, query) {
    var ctrl = hackyGetSearchCtrl(editor);
    var state = ctrl.getState();
    if (!state.isRevealed) {
        ctrl.start({
            forceRevealReplace: true,
            seedSearchStringFromSelection: false,
            shouldFocus: 0,
            shouldAnimate: false,
        });
    }
    var searchString = query.query, isRegex = query.isRegex, isCaseSensitive = query.isCaseSensitive, isFullWord = query.isFullWord;
    ctrl.setSearchString(searchString);
    state.change({
        isRegex: isRegex,
        matchCase: isCaseSensitive,
        wholeWord: isFullWord
    });
};
var hideSearch = function (editor) {
    var ctrl = hackyGetSearchCtrl(editor);
    ctrl.closeFindWidget();
};
var findNextIfNotAlreadyDoing = function (editor, query) {
    var ctrl = hackyGetSearchCtrl(editor);
    if (!ctrl.getState().isRevealed) {
        startSearch(editor, query);
    }
    else {
        ctrl.moveToNextMatch();
    }
};
var findPreviousIfNotAlreadyDoing = function (editor, query) {
    var ctrl = hackyGetSearchCtrl(editor);
    if (!ctrl.getState().isRevealed) {
        startSearch(editor, query);
    }
    else {
        ctrl.moveToPrevMatch();
    }
};
var simpleReplaceNext = function (editor, newText) {
    var ctrl = hackyGetSearchCtrl(editor);
    // Set new text
    hackySetReplaceText(ctrl, newText);
    // trigger the replace action
    ctrl.replace();
};
var simpleReplacePrevious = function (editor, newText) {
    var ctrl = hackyGetSearchCtrl(editor);
    // Set new text
    hackySetReplaceText(ctrl, newText);
    // trigger the replace all
    hackyReplacePrevious(editor, ctrl, newText);
};
var simpleReplaceAll = function (editor, newText) {
    var ctrl = hackyGetSearchCtrl(editor);
    // Set new text
    hackySetReplaceText(ctrl, newText);
    // trigger the replace all
    ctrl.replaceAll();
};
/**
 * Our interactions with monaco
 */
var hackyGetSearchCtrl = function (editor) {
    /**
     * HACK
     * https://github.com/Microsoft/vscode/blob/814f92341aa9d3f772b17bf6d46a4e04f2c96959/src/vs/editor/contrib/find/common/findController.ts#L52-L54
     */
    return editor.getContribution('editor.contrib.findController');
};
var hackySetReplaceText = function (ctrl, newText) {
    // HACK to inject at new text:
    ctrl.getState()._replaceString = newText;
};
var hackyReplacePrevious = function (editor, ctrl, newText) {
    // If it is on a match it should just replace. Othewise it should go the the previous match
    // HACK: get the model
    var model = ctrl._model;
    // HACK: the following is pretty much a duplicate of `replace` from model
    // HACK: we made public a few `model` functions
    // But for actions we delegate to `ctrl` ;)
    if (!model._hasMatches()) {
        return;
    }
    var selection = editor.getSelection();
    var selectionText = editor.getModel().getValueInRange(selection);
    if (model._rangeIsMatch(selection)) {
        // selection sits on a find match => replace it!
        ctrl.replace();
        ctrl.moveToPrevMatch();
    }
    else {
        ctrl.moveToPrevMatch();
    }
};
