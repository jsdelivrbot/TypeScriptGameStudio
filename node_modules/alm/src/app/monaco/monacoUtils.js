"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var editorOperationCounter = 0;
function replaceSelection(config) {
    var selection = config.editor.getSelection();
    var editOperation = {
        identifier: {
            major: 0,
            minor: ++editorOperationCounter,
        },
        text: config.newText,
        range: selection,
        forceMoveMarkers: false,
    };
    config.editor.getModel().pushEditOperations([], [editOperation], null);
}
exports.replaceSelection = replaceSelection;
function replaceRange(config) {
    var editOperation = {
        identifier: {
            major: 0,
            minor: ++editorOperationCounter,
        },
        text: config.newText,
        range: new monaco.Range(config.range.startLineNumber, config.range.startColumn, config.range.endLineNumber, config.range.endColumn),
        forceMoveMarkers: false,
        isAutoWhitespaceEdit: false,
    };
    config.model.pushEditOperations([], [editOperation], null);
}
exports.replaceRange = replaceRange;
function writeString(config) {
    var editOperation = {
        identifier: {
            major: 0,
            minor: ++editorOperationCounter,
        },
        text: config.str,
        range: new monaco.Range(config.pos.lineNumber, config.pos.column, config.pos.lineNumber, config.pos.column),
        /** Needed to change selection */
        forceMoveMarkers: true,
    };
    config.model.pushEditOperations([], [editOperation], null);
}
exports.writeString = writeString;
/** Runs format or format selection (if any) */
function format(config) {
    var action = config.editor.getAction('editor.action.format');
    action.run();
}
exports.format = format;
/**
 * Useful for language query stuff that we want to debounce + cancel if no longer relevant even after the query is made
 */
function onlyLastCallWithDelay(call, token) {
    var delay = 500;
    var timeout;
    var p = new Promise(function (resolve, reject) {
        var later = function () {
            if (token.isCancellationRequested)
                reject('cancelled');
            else {
                call().then(function (res) {
                    if (token.isCancellationRequested)
                        reject('cancelled');
                    else
                        resolve(res);
                });
            }
        };
        timeout = setTimeout(later, delay);
        token.onCancellationRequested(function () {
            clearTimeout(timeout);
            reject('cancelled');
        });
    });
    return p;
}
exports.onlyLastCallWithDelay = onlyLastCallWithDelay;
function setSelection(cfg) {
    var model = cfg.editor.getModel();
    var start = model.getPositionAt(cfg.textSpan.start);
    var end = model.getPositionAt(cfg.textSpan.start + cfg.textSpan.length);
    cfg.editor.setSelection({
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
    });
}
exports.setSelection = setSelection;
function gotoPosition(cfg) {
    var pos = {
        lineNumber: cfg.position.line + 1,
        column: cfg.position.ch + 1,
    };
    cfg.editor.setPosition(pos);
    cfg.editor.revealPosition(pos);
}
exports.gotoPosition = gotoPosition;
function getVisibleLines(editor) {
    // HACK: The current lines visible api
    var range = editor._view.layoutProvider.getLinesViewportData().visibleRange;
    return range;
}
exports.getVisibleLines = getVisibleLines;
/** Note: Only useful if in single cursor mode */
function isCursorInTopHalf(cm) {
    var cursor = cm.getPosition();
    var scrollInfo = getVisibleLines(cm);
    // Closer to top than bottom
    return (cursor.lineNumber - scrollInfo.startLineNumber) < (scrollInfo.endLineNumber - cursor.lineNumber);
}
exports.isCursorInTopHalf = isCursorInTopHalf;
function getSelectionOrCurrentLine(editor) {
    var selection = editor.getSelection();
    var hasSelection = !selection.isEmpty();
    if (hasSelection) {
        var selected = editor.getModel().getValueInRange(selection);
        return selected;
    }
    else {
        var selected = editor.getModel().getLineContent(selection.startLineNumber);
        return selected;
    }
}
exports.getSelectionOrCurrentLine = getSelectionOrCurrentLine;
/**
 * Position conversion functions
 */
function getCurrentPosition(editor) {
    var position = editor.getPosition();
    return editor.getModel().getOffsetAt(position);
}
exports.getCurrentPosition = getCurrentPosition;
function positionToOffset(model, position) {
    return model.getOffsetAt(position);
}
exports.positionToOffset = positionToOffset;
function offsetToPosition(model, offset) {
    return model.getPositionAt(offset);
}
exports.offsetToPosition = offsetToPosition;
