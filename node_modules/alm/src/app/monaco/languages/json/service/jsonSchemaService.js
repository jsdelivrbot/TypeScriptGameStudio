/**
 * From : https://raw.githubusercontent.com/Microsoft/vscode/master/extensions/json/server/src/jsonSchemaService.ts
 *
 * The original has a lot of code (around XHRs and looking up schemas mainly) that we do not need
 *
 * We simply need the `JSONSchemaService.resolveSchemaContent`
 * - And the class `ResolvedSchema` (not sure I need this yet, but good container for errors)
 */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var localize_1 = require("../core/localize");
var utils = require("../../../../../common/utils");
/**
 * Register our schemas
 * Mostly downloaded from http://json.schemastore.org/
 *
 * New additions need to
 * - Download and put in schemas
 * - Update utils.ts for "supportedConfigFileNames"
 */
exports.schemas = [];
Object.keys(utils.supportedAutocompleteConfigFileNames).forEach(function (fileName) {
    var rawContent = require("../schemas/" + fileName);
    resolveSchemaContent(rawContent); // Mutates it in place
    exports.schemas.push({
        fileName: fileName,
        content: rawContent
    });
});
function getSchemaForResource(filePath) {
    var fileName = utils.getFileName(filePath);
    var schema = exports.schemas.find(function (s) { return s.fileName === fileName; }).content;
    return Promise.resolve(new ResolvedSchema(schema));
}
exports.getSchemaForResource = getSchemaForResource;
/**
 * Copied straight out of JSONSchemaService
 * Resolves *links* in schema definitions
 * NOTE: Mutates the argument `schema` too!
 */
function resolveSchemaContent(schema) {
    var _this = this;
    var resolveErrors = [];
    var findSection = function (schema, path) {
        if (!path) {
            return schema;
        }
        var current = schema;
        path.substr(1).split('/').some(function (part) {
            current = current[part];
            return !current;
        });
        return current;
    };
    var resolveLink = function (node, linkedSchema, linkPath) {
        var section = findSection(linkedSchema, linkPath);
        if (section) {
            for (var key in section) {
                if (section.hasOwnProperty(key) && !node.hasOwnProperty(key)) {
                    node[key] = section[key];
                }
            }
        }
        else {
            resolveErrors.push(localize_1.localize('json.schema.invalidref', '$ref \'{0}\' in {1} can not be resolved.', linkPath, linkedSchema.id));
        }
        delete node.$ref;
    };
    var resolveExternalLink = function (node, uri, linkPath) {
        return _this.getOrAddSchemaHandle(uri).getUnresolvedSchema().then(function (unresolvedSchema) {
            if (unresolvedSchema.errors.length) {
                var loc = linkPath ? uri + '#' + linkPath : uri;
                resolveErrors.push(localize_1.localize('json.schema.problemloadingref', 'Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
            }
            resolveLink(node, unresolvedSchema.schema, linkPath);
            return resolveRefs(node, unresolvedSchema.schema);
        });
    };
    var resolveRefs = function (node, parentSchema) {
        var toWalk = [node];
        var seen = [];
        var openPromises = [];
        var collectEntries = function () {
            var entries = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                entries[_i] = arguments[_i];
            }
            for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
                var entry = entries_1[_a];
                if (typeof entry === 'object') {
                    toWalk.push(entry);
                }
            }
        };
        var collectMapEntries = function () {
            var maps = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                maps[_i] = arguments[_i];
            }
            for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {
                var map = maps_1[_a];
                if (typeof map === 'object') {
                    for (var key in map) {
                        var entry = map[key];
                        toWalk.push(entry);
                    }
                }
            }
        };
        var collectArrayEntries = function () {
            var arrays = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arrays[_i] = arguments[_i];
            }
            for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {
                var array = arrays_1[_a];
                if (Array.isArray(array)) {
                    toWalk.push.apply(toWalk, array);
                }
            }
        };
        while (toWalk.length) {
            var next = toWalk.pop();
            if (seen.indexOf(next) >= 0) {
                continue;
            }
            seen.push(next);
            if (next.$ref) {
                var segments = next.$ref.split('#', 2);
                if (segments[0].length > 0) {
                    openPromises.push(resolveExternalLink(next, segments[0], segments[1]));
                    continue;
                }
                else {
                    resolveLink(next, parentSchema, segments[1]);
                }
            }
            collectEntries(next.items, next.additionalProperties, next.not);
            collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
            collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);
        }
        return Promise.all(openPromises);
    };
    return resolveRefs(schema, schema).then(function (_) { return new ResolvedSchema(schema, resolveErrors); });
}
exports.resolveSchemaContent = resolveSchemaContent;
var ResolvedSchema = (function () {
    function ResolvedSchema(schema, errors) {
        if (errors === void 0) { errors = []; }
        this.schema = schema;
        this.errors = errors;
    }
    ResolvedSchema.prototype.getSection = function (path) {
        return this.getSectionRecursive(path, this.schema);
    };
    ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {
        var _this = this;
        if (!schema || path.length === 0) {
            return schema;
        }
        var next = path.shift();
        if (schema.properties && schema.properties[next]) {
            return this.getSectionRecursive(path, schema.properties[next]);
        }
        else if (schema.patternProperties) {
            Object.keys(schema.patternProperties).forEach(function (pattern) {
                var regex = new RegExp(pattern);
                if (regex.test(next)) {
                    return _this.getSectionRecursive(path, schema.patternProperties[pattern]);
                }
            });
        }
        else if (schema.additionalProperties) {
            return this.getSectionRecursive(path, schema.additionalProperties);
        }
        else if (next.match('[0-9]+')) {
            if (schema.items) {
                return this.getSectionRecursive(path, schema.items);
            }
            else if (Array.isArray(schema.items)) {
                try {
                    var index = parseInt(next, 10);
                    if (schema.items[index]) {
                        return this.getSectionRecursive(path, schema.items[index]);
                    }
                    return null;
                }
                catch (e) {
                    return null;
                }
            }
        }
        return null;
    };
    return ResolvedSchema;
}());
exports.ResolvedSchema = ResolvedSchema;
