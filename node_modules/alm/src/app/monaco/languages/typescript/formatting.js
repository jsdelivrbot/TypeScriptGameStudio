"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var socketClient_1 = require("../../../../socket/socketClient");
var state = require("../../../state/state");
var DocumentFormatter = (function () {
    function DocumentFormatter() {
    }
    DocumentFormatter.prototype.provideDocumentFormattingEdits = function (model, options, token) {
        var filePath = model.filePath;
        if (!state.inActiveProjectFilePath(model.filePath)) {
            return Promise.resolve([]);
        }
        return socketClient_1.server.formatDocument({
            filePath: filePath, editorOptions: model._editorOptions
        }).then(function (res) {
            if (token.isCancellationRequested)
                return [];
            return res.edits.map(formattingEditToSingleEditOperation);
        });
    };
    return DocumentFormatter;
}());
exports.DocumentFormatter = DocumentFormatter;
var DocumentRangeFormatter = (function () {
    function DocumentRangeFormatter() {
    }
    DocumentRangeFormatter.prototype.provideDocumentRangeFormattingEdits = function (model, range, options, token) {
        var filePath = model.filePath;
        if (!state.inActiveProjectFilePath(model.filePath)) {
            return Promise.resolve([]);
        }
        return socketClient_1.server.formatDocumentRange({
            filePath: filePath,
            editorOptions: model._editorOptions,
            from: {
                line: range.startLineNumber - 1,
                ch: range.startColumn - 1,
            },
            to: {
                line: range.endLineNumber - 1,
                ch: range.endColumn - 1,
            }
        }).then(function (res) {
            if (token.isCancellationRequested)
                return [];
            return res.edits.map(formattingEditToSingleEditOperation);
        });
    };
    return DocumentRangeFormatter;
}());
exports.DocumentRangeFormatter = DocumentRangeFormatter;
var FormatOnTypeAdapter = (function () {
    function FormatOnTypeAdapter() {
    }
    Object.defineProperty(FormatOnTypeAdapter.prototype, "autoFormatTriggerCharacters", {
        get: function () {
            return [';', '}', '\n'];
        },
        enumerable: true,
        configurable: true
    });
    FormatOnTypeAdapter.prototype.provideOnTypeFormattingEdits = function (model, position, ch, options, token) {
        var filePath = model.filePath;
        var empty = Promise.resolve([]);
        if (!state.inActiveProjectFilePath(model.filePath)) {
            return empty;
        }
        /**
         * If the user just did a docblockr enter
         * And we insert stuff like `* `
         * Then ts will remove the trailing space.
         * We want to keep that so check for it
         */
        var lineContent = model.getLineContent(position.lineNumber);
        if (lineContent.endsWith('* ')
            || lineContent.endsWith('// ')
            || lineContent.endsWith('/// ')) {
            return empty;
        }
        return socketClient_1.server.getFormattingEditsAfterKeystroke({
            filePath: filePath,
            editorPosition: {
                line: position.lineNumber - 1,
                ch: position.column - 1
            },
            key: ch,
            editorOptions: model._editorOptions
        }).then(function (res) {
            if (token.isCancellationRequested)
                return [];
            return res.edits.map(formattingEditToSingleEditOperation);
        });
    };
    return FormatOnTypeAdapter;
}());
exports.FormatOnTypeAdapter = FormatOnTypeAdapter;
/** Utility */
function formattingEditToSingleEditOperation(edit) {
    var result = {
        range: {
            startLineNumber: edit.from.line + 1,
            startColumn: edit.from.ch + 1,
            endLineNumber: edit.to.line + 1,
            endColumn: edit.to.ch + 1
        },
        text: edit.newText
    };
    return result;
}
