"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("../../../common/events");
var socketClient_1 = require("../../../socket/socketClient");
var utils = require("../../../common/utils");
var state = require("../../state/state");
require('./quickFix.css');
var quickFixClassName = 'monaco-quickfix';
var quickFixDecorationOptions = {
    glyphMarginClassName: quickFixClassName,
    isWholeLine: true,
    hoverMessage: 'QuickFixes available. Click to select.'
};
function setup(editor) {
    // if (cm) return { dispose: () => null }; // DEBUG : while the feature isn't complete used to disable it
    var disposed = false;
    var lastWidget = null;
    // The key quick fix get logic
    var refreshQuickFixes = function () {
        if (disposed)
            return;
        // Clear any previous attempt
        editor._lastQuickFixInformation = null;
        if (lastWidget) {
            editor.removeContentWidget(lastWidget);
            lastWidget = null;
        }
        // If not active project return
        if (!state.inActiveProjectFilePath(editor.filePath)) {
            return;
        }
        var indentSize = editor.getModel().getOptions().tabSize;
        var pos = editor.getPosition();
        var position = editor.getModel().getOffsetAt(pos);
        // query the server with live analysis
        socketClient_1.server.getQuickFixes({
            indentSize: indentSize,
            filePath: editor.filePath,
            position: position
        }).then(function (res) {
            // If no longer relevant abort and wait for a new call.
            var newPos = editor.getPosition();
            if (!newPos.equals(pos))
                return;
            /** Only add the decoration if there are some fixes available */
            if (res.fixes.length) {
                editor._lastQuickFixInformation = { res: res, position: position };
                // Setup the marker. Note: Must be done outside `getDomNode` to make it idempotent
                var marker = document.createElement("div");
                marker.className = quickFixClassName;
                marker.title = "Quick fixes available";
                marker.innerHTML = "ðŸ’¡";
                marker.onclick = function () {
                    runQuickFixSelector(editor);
                };
                lastWidget = {
                    allowEditorOverflow: false,
                    getId: function () { return 'quickfix'; },
                    getDomNode: function () { return marker; },
                    getPosition: function () {
                        return {
                            position: { lineNumber: pos.lineNumber, column: editor.getModel().getLineContent(pos.lineNumber).length + 1 },
                            preference: [
                                monaco.editor.ContentWidgetPositionPreference.EXACT,
                            ]
                        };
                    }
                };
                editor.addContentWidget(lastWidget);
            }
        });
    };
    var refreshQuickFixesDebounced = utils.debounce(refreshQuickFixes, 1000);
    var disposible = new events_1.CompositeDisposible();
    disposible.add(editor.onDidFocusEditor(refreshQuickFixesDebounced));
    disposible.add(editor.onDidChangeModelContent(refreshQuickFixesDebounced));
    disposible.add(editor.onDidChangeCursorPosition(refreshQuickFixesDebounced));
    disposible.add(socketClient_1.cast.activeProjectConfigDetailsUpdated.on(function () {
        refreshQuickFixesDebounced();
    }));
    disposible.add({
        dispose: function () {
            disposed = true;
        }
    });
    return disposible;
}
exports.setup = setup;
var CommonEditorRegistry = monaco.CommonEditorRegistry;
var EditorAction = monaco.EditorAction;
var KeyMod = monaco.KeyMod;
var KeyCode = monaco.KeyCode;
var EditorContextKeys = monaco.EditorContextKeys;
var selectListView = require("../../selectListView");
var ui = require("../../ui");
var uix = require("../../uix");
var React = require("react");
var QuickFixAction = (function (_super) {
    __extends(QuickFixAction, _super);
    function QuickFixAction() {
        return _super.call(this, {
            id: QuickFixAction.ID,
            label: 'TypeScript Quick Fix',
            alias: 'TypeScript Quick Fix',
            precondition: EditorContextKeys.Focus,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: KeyMod.Alt | KeyCode.Enter
            }
        }) || this;
    }
    QuickFixAction.prototype.run = function (accessor, editor) {
        runQuickFixSelector(editor);
    };
    QuickFixAction.ID = 'editor.action.quickfix';
    return QuickFixAction;
}(EditorAction));
function runQuickFixSelector(editor) {
    var cm = editor;
    if (!cm._lastQuickFixInformation) {
        ui.notifyInfoNormalDisappear('No active quick fixes for last editor position');
        return;
    }
    var fixes = cm._lastQuickFixInformation.res.fixes;
    selectListView.selectListView.show({
        header: 'ðŸ’¡ Quick Fixes',
        data: fixes,
        render: function (fix, highlighted) {
            return React.createElement("div", { style: { fontFamily: 'monospace' } }, highlighted);
        },
        textify: function (fix) { return fix.display; },
        onSelect: function (fix) {
            /**
             * For each ts code fix its expected to request formatting as well
             * https://github.com/Microsoft/TypeScript/issues/12249
             * So add them to the refactorings
             * The backend can't do it as the file hasn't been edited yet. Have to request from frontend :-/
             *
             * But its probably not worth too much trouble for now so ignoring.
             **/
            // tsCodeFix.changes.forEach(change => {
            //     change.textChanges.forEach(tc => {
            //         /** The end depends on the old text vs. the new text. But always greater than start (good enough) */
            //         let end = tc.span.start + tc.newText.length - tc.span.length;
            //         if (end < tc.span.start) end = tc.span.start;
            //         let start = tc.span.start;
            //         let tsresult = formatting.formatDocumentRangeUsingPos(project, change.fileName, start, end,
            //             /**
            //              * This is not 100% correct as the changed file can be different.
            //              * But the likelyhood of the *other* project file having different formatting requirements is very low
            //              **/
            //             query.editorOptions
            //         );
            //         console.log(tsresult, change.fileName, tc.span, end);
            //         tsresult.forEach(formatting => {
            //             refactorings.push({
            //                 filePath: change.fileName,
            //                 newText: formatting.newText,
            //                 span: formatting.span
            //             });
            //         })
            //     });
            // });
            socketClient_1.server.applyQuickFix({
                key: fix.key,
                indentSize: cm.getModel().getOptions().tabSize,
                additionalData: null,
                filePath: cm.filePath,
                position: cm._lastQuickFixInformation.position,
            }).then(function (res) {
                // apply refactorings
                // console.log('Apply refactorings:', res.refactorings); // DEBUG
                uix.API.applyRefactorings(res.refactorings);
            });
            return '';
        }
    });
}
CommonEditorRegistry.registerEditorAction(new QuickFixAction());
