"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Original version from https://github.com/alexandrudima/monaco-typescript/blob/1af97f4c0bc7514ea1f1ba62d9098aa883595918/src/languageFeatures.ts
 *
 * Modified to
 * - use our live error pushing
 * - use `filePath` instead of `uri`
 */
var events = require("../../../common/events");
var globalErrorCacheClient_1 = require("../../globalErrorCacheClient");
require('./linter.css');
var gutterClassName = 'monaco-lint-marker-error';
var gutterDecorationOptions = {
    glyphMarginClassName: gutterClassName,
    isWholeLine: true,
    hoverMessage: 'Errors exist in code on this line.'
};
function codeErrorToMonacoError(codeError) {
    return {
        severity: codeError.level === 'error' ? monaco.Severity.Error : monaco.Severity.Warning,
        message: codeError.message,
        startLineNumber: codeError.from.line + 1,
        startColumn: codeError.from.ch + 1,
        endLineNumber: codeError.to.line + 1,
        endColumn: codeError.to.ch + 1,
    };
}
function setup(editor) {
    // if (editor) return { dispose: () => null }; // DEBUG : while the feature isn't complete used to disable it
    var lastDecorations = [];
    function performLint() {
        var filePath = editor.filePath;
        var model = editor.getModel();
        var rawErrors = globalErrorCacheClient_1.errorsCache.getErrorsForFilePath(filePath);
        // console.log('here', rawErrors); // DEBUG
        // Set inline markers. Monaco also uses these for `f8` next error nav.
        var markers = rawErrors.map(codeErrorToMonacoError);
        monaco.editor.setModelMarkers(model, 'alm-linter', markers);
        // Set gutter decorations
        var newDecorations = rawErrors.map(function (override) {
            var result = {
                range: {
                    startLineNumber: override.from.line + 1,
                    endLineNumber: override.to.line + 1,
                },
                options: gutterDecorationOptions
            };
            return result;
        });
        lastDecorations = editor.deltaDecorations(lastDecorations, newDecorations);
    }
    // Perform an initial lint
    performLint();
    var disposible = new events.CompositeDisposible();
    // Subscribe for future updates
    disposible.add(globalErrorCacheClient_1.errorsCache.errorsDelta.on(performLint));
    /**
     * Also subscribe to the user clicking the margin
     */
    disposible.add(editor.onMouseUp(function (mouseEvent) {
        if (mouseEvent.target.type === monaco.editor.MouseTargetType.GUTTER_GLYPH_MARGIN
            && mouseEvent.target.element.className.includes(gutterClassName)) {
            var position_1 = mouseEvent.target.position;
            if (position_1) {
                var rawErrors = globalErrorCacheClient_1.errorsCache.getErrorsForFilePath(editor.filePath);
                var error = rawErrors.find(function (x) { return x.from.line === position_1.lineNumber - 1; });
                if (error) {
                    editor.setPosition({
                        lineNumber: error.from.line + 1,
                        column: error.from.ch + 1
                    });
                }
            }
        }
    }));
    return disposible;
}
exports.setup = setup;
