"use strict";
/**
 * Wraps fs and path into a nice "consistentPath" API
 */
Object.defineProperty(exports, "__esModule", { value: true });
/** we work with "/" for all paths (so does the typescript language service) */
function consistentPath(filePath) {
    return filePath.split('\\').join('/');
}
exports.consistentPath = consistentPath;
var path = require("path");
var fs = require("fs");
var mkdirp = require("mkdirp");
var rimraf = require("rimraf");
/**
 * Resolves to to an absolute path.
 * @param from,to,to,to...
 */
function resolve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return consistentPath(path.resolve.apply(path, args));
}
exports.resolve = resolve;
/**
 * Could be called ends with :)
 */
function isExt(path, ext) {
    return path && ext && path.indexOf(ext, path.length - ext.length) !== -1;
}
exports.isExt = isExt;
/**
 * Converts "C:\boo" , "C:\boo\foo.ts" => "./foo.ts"; Works on unix as well.
 */
function makeRelativePath(relativeFolder, filePath) {
    var relativePath = path.relative(relativeFolder, filePath).split('\\').join('/');
    if (relativePath[0] !== '.') {
        relativePath = './' + relativePath;
    }
    return relativePath;
}
exports.makeRelativePath = makeRelativePath;
function removeExt(filePath) {
    var lastIndex = filePath.lastIndexOf('.');
    if (lastIndex == -1 /** Didn't find `.` */
        || (lastIndex === 0 && (filePath[1] === '/' || filePath[2] === '/'))) {
        return filePath;
    }
    return filePath.substr(0, lastIndex);
}
exports.removeExt = removeExt;
function readFile(filePath) {
    return fs.readFileSync(filePath, 'utf8');
}
exports.readFile = readFile;
/** Will write the file and even make directories if needed */
function writeFile(filePath, content) {
    mkdirp.sync(path.dirname(filePath));
    fs.writeFileSync(filePath, content, { encoding: 'utf8' });
}
exports.writeFile = writeFile;
function deleteFile(filePath) {
    fs.unlinkSync(filePath);
}
exports.deleteFile = deleteFile;
function deleteDir(dirPath) {
    return new Promise(function (resolve) {
        rimraf(dirPath, { glob: false, maxBusyTries: 10 }, function (e) {
            if (e) {
                console.error('Failed to delete Dir: ', dirPath);
            }
            resolve({});
        });
    });
}
exports.deleteDir = deleteDir;
/** see if a file exists */
exports.existsSync = function (filePath) { return fs.existsSync(filePath); };
/** see if path is absolute */
exports.isAbsolute = function (filePath) { return path.isAbsolute(filePath); };
/** is the filePath a directory? */
exports.isDir = function (filePath) { return fs.lstatSync(filePath).isDirectory(); };
/**
 * See if path is relative.
 */
//  Not particularly awesome e.g. '/..foo' will be not relative ,
//  but it shouldn't matter as the significance is really about if `cwd` matters
function isRelative(str) {
    if (!str.length)
        return false;
    return str[0] == '.' || str.substring(0, 2) == "./" || str.substring(0, 3) == "../";
}
exports.isRelative = isRelative;
/**
  * returns the path if found
  * @throws an error "not found" if not found */
function travelUpTheDirectoryTreeTillYouFind(startDir, fileOrDirectory, 
    /** This is useful if we don't want to file `node_modules from inside node_modules` */
    abortIfInside) {
    /** This is useful if we don't want to file `node_modules from inside node_modules` */
    if (abortIfInside === void 0) { abortIfInside = false; }
    while (fs.existsSync(startDir)) {
        var potentialFile = startDir + '/' + fileOrDirectory;
        /** This means that we were *just* in this directory */
        if (before == potentialFile) {
            if (abortIfInside) {
                throw new Error("not found");
            }
        }
        if (fs.existsSync(potentialFile)) {
            return consistentPath(potentialFile);
        }
        else {
            var before = startDir;
            startDir = path.dirname(startDir);
            // At root:
            if (startDir == before)
                throw new Error("not found");
        }
    }
}
exports.travelUpTheDirectoryTreeTillYouFind = travelUpTheDirectoryTreeTillYouFind;
/**
 * Gets the sub directories of a directory
 */
function getDirs(rootDir) {
    var files = fs.readdirSync(rootDir);
    var dirs = [];
    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
        var file = files_1[_i];
        if (file[0] != '.') {
            var filePath = rootDir + "/" + file;
            var stat = fs.statSync(filePath);
            if (stat.isDirectory()) {
                dirs.push(filePath);
            }
        }
    }
    return dirs;
}
exports.getDirs = getDirs;
