"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("../../../../common/events");
var utils_1 = require("../../../../common/utils");
var equal = require("deep-equal");
// What we use to identify a unique test
var same = function (a, b) {
    return equal(a, b);
};
/**
 * Maintains the list of tests that have been encountered,
 * and notifies anyone who is concerned of updated values
 */
var TestResultsCache = (function () {
    function TestResultsCache() {
        var _this = this;
        /**
         * When a cache boots up (e.g. server restart). Its good to know if its an initial test run
         * If so the client might want to clear all previous results
         */
        this.initial = true;
        /**
         * Event that can be wired up to sync one cache with another
         */
        this.testResultsDelta = new events_1.TypedEvent();
        /**
         * You can wire up an errors Delta from one cache to this one.
         */
        this.applyTestResultsDelta = function (delta) {
            if (delta.initial) {
                _this.current = delta.updatedModuleMap;
            }
            else {
                Object.keys(delta.updatedModuleMap).forEach(function (filePath) {
                    _this.current[filePath] = delta.updatedModuleMap[filePath];
                });
                delta.clearedModules.forEach(function (fp) {
                    delete _this.current[fp];
                });
            }
            _this.sendDelta();
        };
        /**
         *  DELTA MAINTAINANCE
         */
        this.last = Object.create(null);
        /**
         * current errors
         */
        this.current = Object.create(null);
        /**
         * debounced as constantly sending updates quickly degrades the web experience
         */
        this.sendDelta = utils_1.debounce(function () {
            // TODO Create a delta
            var last = _this.last;
            var current = _this.current;
            var delta = {
                updatedModuleMap: Object.create(null),
                clearedModules: [],
                initial: _this.initial,
            };
            _this.initial = false;
            Object.keys(current).forEach(function (fp) {
                // Added
                if (!last[fp]) {
                    delta.updatedModuleMap[fp] = current[fp];
                }
                else if (!same(current[fp], last[fp])) {
                    delta.updatedModuleMap[fp] = current[fp];
                }
            });
            /** Removed */
            Object.keys(last).forEach(function (fp) {
                if (!_this.current[fp]) {
                    delta.clearedModules.push(fp);
                }
            });
            // Preserve for future delta
            _this.last = Object.create(null);
            Object.keys(_this.current).map(function (fp) { return _this.last[fp] = _this.current[fp]; });
            // Send out the delta
            _this.testResultsDelta.emit(delta);
        }, 250);
        /** The passed results are considered the only ones. All else is cleared */
        this.setResultsTotal = function (results) {
            _this.current = Object.create(null);
            results.forEach(function (res) {
                _this.current[res.filePath] = res;
            });
            _this.sendDelta();
        };
        /** Only for one file */
        this.addResult = function (result) {
            _this.current[result.filePath] = result;
            _this.sendDelta();
        };
        /**
         * Clear all results. Resets the cache.
         *
         * Also good or an initial sync.
         * e.g. when the socket server reboots
         *   it wants to clear any errors that any connected clicks might have
         */
        this.clearResults = function () {
            _this.current = Object.create(null);
            _this.sendDelta();
        };
        /**
         * Get the last results so you can start listening to new deltas
         */
        this.getResults = function () { return _this.last; };
        /** set after initial sync */
        this.setResults = function (results) {
            _this.current = results;
            _this.sendDelta();
        };
        /**
         * Collects overall stats
         */
        this.getStats = function () {
            var allModules = Object.keys(_this.current).map(function (k) { return _this.current[k]; });
            var sumReducer = function (arr) { return arr.reduce(function (i, acc) { return acc + i; }, 0); };
            var result = {
                testCount: sumReducer(allModules.map(function (x) { return x.stats.testCount; })),
                passCount: sumReducer(allModules.map(function (x) { return x.stats.passCount; })),
                failCount: sumReducer(allModules.map(function (x) { return x.stats.failCount; })),
                skipCount: sumReducer(allModules.map(function (x) { return x.stats.skipCount; })),
                durationMs: sumReducer(allModules.map(function (x) { return x.stats.durationMs; })),
            };
            return result;
        };
    }
    return TestResultsCache;
}());
exports.TestResultsCache = TestResultsCache;
