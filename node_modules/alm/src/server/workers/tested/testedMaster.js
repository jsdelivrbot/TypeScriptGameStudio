"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var sw = require("../../utils/simpleWorker");
var contract = require("./testedContract");
var utils_1 = require("../../../common/utils");
var events_1 = require("../../../common/events");
/** This is were we push the errors */
var globalErrorCacheServer_1 = require("../../globalErrorCacheServer");
var testResultCache = require("./common/testResultsCache");
exports.testCache = new testResultCache.TestResultsCache();
exports.working = new events_1.TypedEvent();
var Master;
(function (Master) {
    Master.receiveTestResultsDelta = function (data) {
        exports.testCache.applyTestResultsDelta(data);
        return utils_1.resolve({});
    };
    Master.receiveErrorCacheDelta = function (data) {
        globalErrorCacheServer_1.errorsCache.applyDelta(data);
        return utils_1.resolve({});
    };
    Master.receiveWorking = function (data) {
        exports.working.emit(data);
        return utils_1.resolve({});
    };
})(Master || (Master = {}));
// Ensure that the namespace follows the contract
var _checkTypes = Master;
// launch worker
exports.worker = sw.startWorker({
    workerPath: __dirname + '/testedWorker',
    workerContract: contract.worker,
    masterImplementation: Master
}).worker;
var fmc = require("../../disk/fileModelCache");
var wd = require("../../disk/workingDir");
var activeProjectConfig = require("../../disk/activeProjectConfig");
/**
 * Some things e.g. filePaths updated happen a lot.
 * So debounce this
 */
var syncDebounced = utils_1.debounce(function () { return exports.worker.init({ workingDir: wd.getProjectRoot() }); }, 500);
function start() {
    /** Start up the working with working dir */
    wd.projectRootUpdated.on(syncDebounced);
    /** File save */
    fmc.didStatusChange.on(function (update) {
        // saved ones as worker reads directly from disk and works on whole file contents
        update.saved && exports.worker.fileSaved({ filePath: update.filePath });
        /**
         * If a saved file is in the compilation context we should really run all tests
         * untill we have a better dependency analysis
         */
        activeProjectConfig.projectFilePathsUpdated.current().then(function (res) {
            if (res.filePaths.some(function (fp) { return fp === update.filePath; })) {
                syncDebounced();
            }
        });
    });
    /**
     * New test file added to the directory
     * NOTE: it works because
     *  - new test files should also be a part of the compilation context
     *    And that triggers a file paths update ;)
     */
    activeProjectConfig.projectFilePathsUpdated.on(syncDebounced);
}
exports.start = start;
