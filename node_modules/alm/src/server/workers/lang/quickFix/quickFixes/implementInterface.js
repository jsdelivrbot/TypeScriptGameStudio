"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ast = require("../../modules/astUtils");
var EOL = '\n';
function getClassAndInterfaceName(error) {
    var errorText = ts.flattenDiagnosticMessageText(error.messageText, EOL);
    var match = errorText.match(/Class \'(\w+)\' incorrectly implements interface \'(\w+)\'./);
    // safety
    if (!match || match.length !== 3)
        return;
    var className = match[1], interfaceName = match[2];
    return { className: className, interfaceName: interfaceName };
}
var ImplementInterface = (function () {
    function ImplementInterface() {
        this.key = ImplementInterface.name;
    }
    ImplementInterface.prototype.canProvideFix = function (info) {
        var relevantError = info.positionErrors.filter(function (x) { return x.code == ts.Diagnostics.Class_0_incorrectly_implements_interface_1.code; })[0];
        if (!relevantError)
            return;
        if (info.positionNode.kind !== ts.SyntaxKind.Identifier)
            return;
        var match = getClassAndInterfaceName(relevantError);
        if (!match)
            return;
        var className = match.className, interfaceName = match.interfaceName;
        return { display: "Implement members of " + interfaceName + " in " + className };
    };
    ImplementInterface.prototype.provideFix = function (info) {
        var relevantError = info.positionErrors.filter(function (x) { return x.code == ts.Diagnostics.Class_0_incorrectly_implements_interface_1.code; })[0];
        if (!relevantError)
            return;
        if (info.positionNode.kind !== ts.SyntaxKind.Identifier)
            return;
        var match = getClassAndInterfaceName(relevantError);
        var className = match.className, interfaceName = match.interfaceName;
        // Get all the members of the interface:
        var interfaceTarget = ast.getNodeByKindAndName(info.program, ts.SyntaxKind.InterfaceDeclaration, className);
        // The class that we are trying to add stuff to
        var classTarget = ast.getNodeByKindAndName(info.program, ts.SyntaxKind.ClassDeclaration, className);
        // Then the last brace
        var braces = classTarget.getChildren().filter(function (x) { return x.kind == ts.SyntaxKind.CloseBraceToken; });
        var lastBrace = braces[braces.length - 1];
        // And the correct indent
        var indentLength = info.service.getIndentationAtPosition(classTarget.getSourceFile().fileName, lastBrace.getStart(), info.project.configFile.project.formatCodeOptions);
        var indent = Array(indentLength + info.formatOptions.indentSize + 1).join(' ');
        var refactorings = [];
        //
        // The code for the error is actually from typeChecker.checkTypeRelatedTo so investigate that code more
        // also look at the code from the mixin PR on ms/typescript
        //
        // And add stuff after the last brace
        // let refactoring: Refactoring = {
        //     span: {
        //         start: firstBrace.end,
        //         length: 0
        //     },
        //     newText: `${EOL}${indent}${identifierName}: ${typeString};`,
        //     filePath: targetDeclaration.getSourceFile().fileName
        // };
        return refactorings;
    };
    return ImplementInterface;
}());
exports.ImplementInterface = ImplementInterface;
