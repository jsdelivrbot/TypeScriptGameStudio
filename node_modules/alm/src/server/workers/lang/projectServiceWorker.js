"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Load up TypeScript
 */
var byots = require("byots");
var ensureImport = byots;
var sw = require("../../utils/simpleWorker");
var contract = require("./projectServiceContract");
var activeProject = require("./activeProject");
var outputStatusCache = require("./cache/outputStatusCache");
var projectService = require("./projectService");
var docs = require("./docs/docs");
var umlDiagram = require("./umlDiagram/umlDiagram");
var tsFlow = require("./tsFlow/tsFlow");
var liveAnalysis = require("./liveAnalysis/liveAnalysis");
var Worker;
(function (Worker) {
    Worker.echo = function (data) { return Promise.resolve(data); };
    /**
     * This is sort of the entry point of the worker. Nothing really happens till this gets called
     */
    Worker.setActiveProjectConfigDetails = function (details) {
        var proj = activeProject.setActiveProjectConfigDetails(details.projectData);
        return Promise.resolve({});
    };
    /** Build */
    Worker.build = function (details) {
        var proj = activeProject.GetProject.getCurrentIfAny();
        outputStatusCache.doCompleteProjectCacheUpdate(proj);
        return Promise.resolve({});
    };
    Worker.getJSOutputStatus = function (details) {
        var result = projectService.getJSOutputStatus(details);
        return Promise.resolve(result);
    };
    /**
     * File information updates sent by the master. We tell the modules that care.
     */
    Worker.fileEdited = function (details) {
        activeProject.fileEdited(details);
        outputStatusCache.fileEdited(details);
        return Promise.resolve({});
    };
    Worker.fileChangedOnDisk = function (details) {
        activeProject.fileChangedOnDisk(details);
        outputStatusCache.fileChangedOnDisk(details);
        return Promise.resolve({});
    };
    Worker.fileSaved = function (details) {
        outputStatusCache.fileSaved(details);
        return Promise.resolve({});
    };
    /**
     * Project Service
     */
    Worker.getCompletionsAtPosition = projectService.getCompletionsAtPosition;
    Worker.getCompletionEntryDetails = projectService.getCompletionEntryDetails;
    Worker.quickInfo = projectService.quickInfo;
    Worker.getRenameInfo = projectService.getRenameInfo;
    Worker.getDefinitionsAtPosition = projectService.getDefinitionsAtPosition;
    Worker.getDoctorInfo = projectService.getDoctorInfo;
    Worker.getReferences = projectService.getReferences;
    Worker.formatDocument = projectService.formatDocument;
    Worker.formatDocumentRange = projectService.formatDocumentRange;
    Worker.getNavigateToItems = projectService.getNavigateToItems;
    Worker.getNavigateToItemsForFilePath = projectService.getNavigateToItemsForFilePath;
    Worker.getDependencies = projectService.getDependencies;
    Worker.getAST = projectService.getAST;
    Worker.getQuickFixes = projectService.getQuickFixes;
    Worker.applyQuickFix = projectService.applyQuickFix;
    Worker.getSemanticTree = projectService.getSemanticTree;
    Worker.getOccurrencesAtPosition = projectService.getOccurrencesAtPosition;
    Worker.getFormattingEditsAfterKeystroke = projectService.getFormattingEditsAfterKeystroke;
    Worker.removeUnusedImports = projectService.removeUnusedImports;
    /**
     * Documentation Browser
     */
    Worker.getTopLevelModuleNames = docs.getTopLevelModuleNames;
    Worker.getUpdatedModuleInformation = docs.getUpdatedModuleInformation;
    /**
     * Uml diagram
     */
    Worker.getUmlDiagramForFile = umlDiagram.getUmlDiagramForFile;
    /**
     * tsFlow
     */
    Worker.getFlowRoots = tsFlow.getFlowRoots;
    /** live analysis */
    Worker.getLiveAnalysis = liveAnalysis.getLiveAnalysis;
})(Worker || (Worker = {}));
// Ensure that the namespace follows the contract
var _checkTypes = Worker;
// run worker
exports.master = sw.runWorker({
    workerImplementation: Worker,
    masterContract: contract.master
}).master;
/**
 * Keep the master in sync with some important stuff
 */
var tsErrorsCache = require("./cache/tsErrorsCache");
tsErrorsCache.errorsCache.errorsDelta.on(function (delta) { return exports.master.receiveErrorCacheDelta(delta); });
outputStatusCache.fileOuputStatusUpdated.on(function (fileOuputStatusUpdate) {
    return exports.master.receiveFileOutputStatusUpdate(fileOuputStatusUpdate);
});
outputStatusCache.completeOutputStatusCacheUpdated.on(function (completeOutputStatusCacheUpdate) { return exports.master.receiveCompleteOutputStatusCacheUpdate(completeOutputStatusCacheUpdate); });
outputStatusCache.liveBuildResults.on(function (liveBuildResults) { return exports.master.receiveLiveBuildResults(liveBuildResults); });
activeProject.working.on(function (working) {
    exports.master.receiveWorking(working);
});
/**
 * We send down the master to `activeProject` otherwise we get in a cyclic reference :-/
 * (activeProject needs us.master to read files) + (we need activeProject to tell it to set active project configuration)
 *
 * Similarly for `project` (project -> usedby -> activeProject -> used by us)
 */
activeProject.setMaster(exports.master);
var project = require("./core/project");
project.setMaster(exports.master);
