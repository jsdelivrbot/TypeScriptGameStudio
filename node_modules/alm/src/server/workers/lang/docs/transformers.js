"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 *
 *
 * Various transformers
 *
 *
 *
 */
/** Imports */
var types = require("../../../../common/types");
var astUtils_1 = require("../modules/astUtils");
var jsDoc_1 = require("../modules/jsDoc");
/** Source File */
function transformSourceFile(sourceFile) {
    var name = sourceFile.fileName;
    var icon = ts.isExternalModule(sourceFile) ? types.IconType.Namespace : types.IconType.Global;
    var comment = jsDoc_1.getParsedComment(sourceFile, sourceFile);
    var subItems = getSignificantSubItems(sourceFile, sourceFile);
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, sourceFile.pos),
    };
}
exports.transformSourceFile = transformSourceFile;
/** There are a few root level things we care about. This only recurses on those ðŸŒ¹  */
function getSignificantSubItems(node, sourceFile) {
    var subItems = [];
    ts.forEachChild(node, function (node) {
        if (node.kind == ts.SyntaxKind.ClassDeclaration) {
            subItems.push(transformClass(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.InterfaceDeclaration) {
            subItems.push(transformInterface(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.EnumDeclaration) {
            subItems.push(transformEnum(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.VariableStatement) {
            transformVariableStatement(node, sourceFile).forEach(function (variable) { return subItems.push(variable); });
        }
        if (node.kind == ts.SyntaxKind.FunctionDeclaration) {
            var functionDeclaration = node;
            /** If it doesn't have a `block` then its an overload. We don't want to visit it */
            if (!functionDeclaration.body)
                return;
            subItems.push(transformFunction(functionDeclaration, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.ModuleDeclaration) {
            subItems.push(transformModule(node, sourceFile));
        }
    });
    return subItems;
}
/** Class */
function transformClass(node, sourceFile) {
    var name = node.name.text;
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.Class;
    if (node.typeParameters) {
        icon = types.IconType.ClassGeneric;
    }
    ts.forEachChild(node, function (node) {
        if (node.kind == ts.SyntaxKind.Constructor) {
            subItems.push(transformClassConstructor(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.PropertyDeclaration) {
            subItems.push(transformClassProperty(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.MethodDeclaration) {
            subItems.push(transformClassMethod(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.IndexSignature) {
            subItems.push(transformClassIndexSignature(node, sourceFile));
        }
    });
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Class Constructor */
function transformClassConstructor(node, sourceFile) {
    var name = "constructor";
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.ClassConstructor;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Class Property */
function transformClassProperty(node, sourceFile) {
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.ClassProperty;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Class Method */
function transformClassMethod(node, sourceFile) {
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.ClassMethod;
    if (node.typeParameters) {
        icon = types.IconType.ClassMethodGeneric;
    }
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Class Index Signature */
function transformClassIndexSignature(node, sourceFile) {
    var name = "Index Signature";
    var comment = '`' + node.getText() + '`' + "\n" + (jsDoc_1.getParsedComment(node, sourceFile) || '');
    var subItems = [];
    var icon = types.IconType.ClassIndexSignature;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Interface */
function transformInterface(node, sourceFile) {
    var name = node.name.text;
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.Interface;
    if (node.typeParameters) {
        icon = types.IconType.InterfaceGeneric;
    }
    ts.forEachChild(node, function (node) {
        if (node.kind == ts.SyntaxKind.ConstructSignature) {
            subItems.push(transformInterfaceConstructor(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.PropertySignature) {
            subItems.push(transformInterfaceProperty(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.MethodSignature) {
            subItems.push(transformInterfaceMethod(node, sourceFile));
        }
        if (node.kind == ts.SyntaxKind.IndexSignature) {
            subItems.push(transformInterfaceIndexSignature(node, sourceFile));
        }
    });
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Interface Property */
function transformInterfaceProperty(node, sourceFile) {
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.InterfaceProperty;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Interface Constructor */
function transformInterfaceConstructor(node, sourceFile) {
    var name = "constructor";
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.InterfaceConstructor;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Interface Method */
function transformInterfaceMethod(node, sourceFile) {
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.InterfaceMethod;
    if (node.typeParameters) {
        icon = types.IconType.InterfaceMethodGeneric;
    }
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Interface Index Signature */
function transformInterfaceIndexSignature(node, sourceFile) {
    var name = "Index Signature";
    var comment = '`' + node.getText() + '`' + "\n" + (jsDoc_1.getParsedComment(node, sourceFile) || '');
    var subItems = [];
    var icon = types.IconType.InterfaceIndexSignature;
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.pos),
    };
}
/** Enum */
function transformEnum(node, sourceFile) {
    var name = node.name.text;
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.Enum;
    ts.forEachChild(node, function (node) {
        if (node.kind == ts.SyntaxKind.EnumMember) {
            var member = node;
            subItems.push({
                name: member.name.getText(),
                icon: types.IconType.EnumMember,
                comment: jsDoc_1.getParsedComment(node, sourceFile),
                subItems: [],
                location: astUtils_1.getDocumentedTypeLocation(sourceFile, member.name.pos),
            });
        }
    });
    return {
        name: name,
        icon: icon,
        comment: comment,
        subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Variable */
function transformVariableStatement(node, sourceFile) {
    var result = [];
    var declarations = node.declarationList.declarations;
    declarations.forEach(function (d) {
        var comment = jsDoc_1.getParsedComment(d, sourceFile);
        var subItems = [];
        var icon = types.IconType.Variable;
        if (d.name.kind === ts.SyntaxKind.ObjectBindingPattern) {
            /** destructured variable declaration */
            var names = d.name;
            names.elements.forEach(function (bindingElement) {
                var name = ts.getPropertyNameForPropertyNameNode(bindingElement.name);
                result.push({
                    name: name, icon: icon, comment: comment, subItems: subItems,
                    location: astUtils_1.getDocumentedTypeLocation(sourceFile, bindingElement.pos),
                });
            });
        }
        else {
            var name_1 = ts.getPropertyNameForPropertyNameNode(d.name);
            result.push({
                name: name_1, icon: icon, comment: comment, subItems: subItems,
                location: astUtils_1.getDocumentedTypeLocation(sourceFile, d.pos),
            });
        }
    });
    return result;
}
/** Function */
function transformFunction(node, sourceFile) {
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    var comment = jsDoc_1.getParsedComment(node, sourceFile);
    var subItems = [];
    var icon = types.IconType.Function;
    if (node.typeParameters) {
        icon = types.IconType.FunctionGeneric;
    }
    return {
        name: name, icon: icon, comment: comment, subItems: subItems,
        location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
    };
}
/** Module | Namespace */
function transformModule(node, sourceFile) {
    /**
     * Namespace chaining basics
     * a.b.c {}
     * a > declaration
     *   b > declaration
     *     c > declaration + body
     *
     * So if no body then we have to go down to get the name.
     * Also we the *body* is were we should recurse
     */
    var icon = types.IconType.Namespace;
    var name = ts.getPropertyNameForPropertyNameNode(node.name);
    if (node.body.kind === ts.SyntaxKind.ModuleDeclaration) {
        name = name + '.';
        var recurse = transformModule(node.body, sourceFile);
        return {
            name: name + recurse.name,
            icon: icon,
            comment: recurse.comment,
            subItems: recurse.subItems,
            location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos),
        };
    }
    else {
        var comment = jsDoc_1.getParsedComment(node, sourceFile);
        var subItems = getSignificantSubItems(node.body, sourceFile);
        return {
            name: name, icon: icon, comment: comment, subItems: subItems, location: astUtils_1.getDocumentedTypeLocation(sourceFile, node.name.pos)
        };
    }
}
// TODO: these
/** Type */
