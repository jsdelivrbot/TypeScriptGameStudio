"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachChild = ts.forEachChild;
function forEachChildRecursive(node, cbNode, depth) {
    if (depth === void 0) { depth = 0; }
    var res = cbNode(node, depth);
    forEachChildRecursive(node, cbNode, depth + 1);
    return res;
}
exports.forEachChildRecursive = forEachChildRecursive;
/** Number to string */
function syntaxKindToString(syntaxKind) {
    return ts.SyntaxKind[syntaxKind];
}
exports.syntaxKindToString = syntaxKindToString;
function getNodeByKindAndName(program, kind, name) {
    var found = undefined;
    function findNode(node) {
        if (node.kind == kind) {
            // Now lookup name:
            if (node.kind == ts.SyntaxKind.ClassDeclaration) {
                if (node.name.text == name) {
                    found = node;
                }
            }
            if (node.kind == ts.SyntaxKind.InterfaceDeclaration) {
                if (node.name.text == name) {
                    found = node;
                }
            }
        }
        if (!found) {
            exports.forEachChild(node, findNode);
        }
    }
    for (var _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
        var file = _a[_i];
        exports.forEachChild(file, findNode);
    }
    return found;
}
exports.getNodeByKindAndName = getNodeByKindAndName;
function getSourceFileImports(srcFile) {
    var modules = [];
    getImports(srcFile, modules);
    return modules;
}
exports.getSourceFileImports = getSourceFileImports;
function getSourceFileImportsWithTextRange(srcFile) {
    var modules = [];
    getImportsWithTextRange(srcFile, modules);
    return modules;
}
exports.getSourceFileImportsWithTextRange = getSourceFileImportsWithTextRange;
// https://github.com/Microsoft/TypeScript/issues/2621#issuecomment-90986004
function getImports(searchNode, importedModules) {
    ts.forEachChild(searchNode, function (node) {
        // Vist top-level import nodes
        if (node.kind === ts.SyntaxKind.ImportDeclaration || node.kind === ts.SyntaxKind.ImportEqualsDeclaration || node.kind === ts.SyntaxKind.ExportDeclaration) {
            var moduleNameExpr = getExternalModuleName(node);
            // if they have a name, that is a string, i.e. not alias defition `import x = y`
            if (moduleNameExpr && moduleNameExpr.kind === ts.SyntaxKind.StringLiteral) {
                importedModules.push(moduleNameExpr.text);
            }
        }
        else if (node.kind === ts.SyntaxKind.ModuleDeclaration && node.name.kind === ts.SyntaxKind.StringLiteral) {
            // Ambient module declaration
            getImports(node.body, importedModules);
        }
    });
}
function getExternalModuleName(node) {
    if (node.kind === ts.SyntaxKind.ImportDeclaration) {
        return node.moduleSpecifier;
    }
    if (node.kind === ts.SyntaxKind.ImportEqualsDeclaration) {
        var reference = node.moduleReference;
        if (reference.kind === ts.SyntaxKind.ExternalModuleReference) {
            return reference.expression;
        }
    }
    if (node.kind === ts.SyntaxKind.ExportDeclaration) {
        return node.moduleSpecifier;
    }
}
/** Note: we exclude the quote characters */
function getImportsWithTextRange(searchNode, importedModules) {
    ts.forEachChild(searchNode, function (node) {
        // Vist top-level import nodes
        if (node.kind === ts.SyntaxKind.ImportDeclaration || node.kind === ts.SyntaxKind.ImportEqualsDeclaration || node.kind === ts.SyntaxKind.ExportDeclaration) {
            var moduleNameExpr = getExternalModuleName(node);
            // if they have a name, that is a string, i.e. not alias defition `import x = y`
            if (moduleNameExpr && moduleNameExpr.kind === ts.SyntaxKind.StringLiteral) {
                var moduleExpr = moduleNameExpr;
                importedModules.push({
                    text: moduleExpr.text,
                    range: { pos: moduleExpr.getStart() + 1, end: moduleExpr.getEnd() - 1 }
                });
            }
        }
        else if (node.kind === ts.SyntaxKind.ModuleDeclaration && node.name.kind === ts.SyntaxKind.StringLiteral) {
            // Ambient module declaration
            getImportsWithTextRange(node.body, importedModules);
        }
    });
}
/**
 * Used by a few things like the documentation view
 */
function getDocumentedTypeLocation(sourceFile, position) {
    /**
     * The actual position of the node will be like
     *
     * <here
     * /** some comment
     * var someNode;
     *
     * Call the `ts.skipTrivia` to get the true node location, but +1 is good enough
     */
    var pos = ts.getLineAndCharacterOfPosition(sourceFile, position + 1);
    return {
        filePath: sourceFile.fileName,
        position: {
            line: pos.line,
            ch: pos.character
        }
    };
}
exports.getDocumentedTypeLocation = getDocumentedTypeLocation;
