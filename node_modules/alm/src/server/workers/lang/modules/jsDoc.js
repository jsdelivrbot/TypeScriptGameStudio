"use strict";
/**
 * NOTE: Pulled straight out of typedoc ðŸŒ¹
 * https://github.com/TypeStrong/typedoc/blob/2e855cf8c62c7813ac62cb1ef911c9a0c5e034c2/src/lib/converter/factories/comment.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the parsed comment for a given node.
 */
function getParsedComment(node, sourceFile) {
    var rawComment = getRawComment(node, sourceFile);
    if (!rawComment) {
        return rawComment;
    }
    return parseComment(rawComment);
}
exports.getParsedComment = getParsedComment;
/**
 * Return the raw comment string for the given node.
 *
 * @param node  The node whose comment should be resolved.
 * @returns     The raw comment string or NULL if no comment could be found.
 */
function getRawComment(node, sourceFile) {
    if (node.parent && node.parent.kind === ts.SyntaxKind.VariableDeclarationList) {
        node = node.parent.parent;
    }
    else if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
        if (!isTopmostModuleDeclaration(node)) {
            return null;
        }
        else {
            node = getRootModuleDeclaration(node);
        }
    }
    var comments = ts.getCommentsFromJSDoc(node);
    if (comments && comments.length) {
        var comment;
        if (node.kind == ts.SyntaxKind.SourceFile) {
            if (comments.length == 1)
                return null;
            comment = comments[0];
        }
        else {
            comment = comments[comments.length - 1];
        }
        return comment;
    }
    else {
        return null;
    }
}
exports.getRawComment = getRawComment;
/**
 * Return the root module declaration of the given module declaration.
 *
 * In the following example this function would always return module
 * <code>A</code> no matter which of the modules was passed in.
 *
 * ```
 * module A.B.C { }
 * ```
 */
function getRootModuleDeclaration(node) {
    while (node.parent && node.parent.kind == ts.SyntaxKind.ModuleDeclaration) {
        var parent_1 = node.parent;
        if (node.name.pos == parent_1.name.end + 1) {
            node = parent_1;
        }
        else {
            break;
        }
    }
    return node;
}
/**
 * Check whether the given module declaration is the topmost.
 *
 * This funtion returns TRUE if there is no trailing module defined, in
 * the following example this would be the case only for module <code>C</code>.
 *
 * ```
 * module A.B.C { }
 * ```
 *
 * @param node  The module definition that should be tested.
 * @return TRUE if the given node is the topmost module declaration, FALSE otherwise.
 */
function isTopmostModuleDeclaration(node) {
    if (node.nextContainer && node.nextContainer.kind == ts.SyntaxKind.ModuleDeclaration) {
        var next = node.nextContainer;
        if (node.name.end + 1 == next.name.pos) {
            return false;
        }
    }
    return true;
}
/**
 * Modified from original to return `string` instead of `Comment` class
 * We lose `tag` information, but that is fine by me for now.
 */
function parseComment(text) {
    var comment = '';
    function consumeTypeData(line) {
        line = line.replace(/^\{[^\}]*\}+/, '');
        line = line.replace(/^\[[^\[][^\]]*\]+/, '');
        return line.trim();
    }
    function readBareLine(line) {
        comment += (comment == '' ? '' : '\n') + line;
    }
    function readLine(line) {
        line = line.replace(/^\s*\*? ?/, '');
        line = line.replace(/\s*$/, '');
        readBareLine(line);
    }
    // text = text.replace(/^\s*\/\*+\s*(\r\n?|\n)/, '');
    // text = text.replace(/(\r\n?|\n)\s*\*+\/\s*$/, '');
    text = text.replace(/^\s*\/\*+/, '');
    text = text.replace(/\*+\/\s*$/, '');
    text.split(/\r\n?|\n/).forEach(readLine);
    return comment;
}
exports.parseComment = parseComment;
