"use strict";
/**
 * Its Types (e.g. enums) + constants :)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheDir = './.alm';
exports.title = "Application Lifecycle Management tools for TypeScript";
var TriState;
(function (TriState) {
    TriState[TriState["Unknown"] = 0] = "Unknown";
    TriState[TriState["True"] = 1] = "True";
    TriState[TriState["False"] = 2] = "False";
})(TriState = exports.TriState || (exports.TriState = {}));
exports.errors = {
    CALLED_WHEN_NO_ACTIVE_PROJECT_FOR_FILE_PATH: "A query *that needs an active project* was made when there is no active project for given filePath",
    CALLED_WHEN_NO_ACTIVE_PROJECT_GLOBAL: "A query *that needs an active project* was made when there is no active project"
};
/**
 * Some session constants
 */
/** When a new server stats up */
exports.urlHashNormal = "root";
/** When user requests a new window */
exports.urlHashNewSession = "new-session";
/** When alm is started ni debug mode */
exports.urlHashDebugSession = "debug";
/**
 * FARM : Don't want to crash by running out of memory / ui preference
 */
exports.maxCountFindAndReplaceMultiResults = 1000;
/**
 * Reason is we want to transact by file path
 * Also, this function sorts per file so you can apply refactorings in order ðŸŒ¹
 */
function getRefactoringsByFilePath(refactorings) {
    var loc = {};
    for (var _i = 0, refactorings_1 = refactorings; _i < refactorings_1.length; _i++) {
        var refac = refactorings_1[_i];
        if (!loc[refac.filePath])
            loc[refac.filePath] = [];
        loc[refac.filePath].push(refac);
    }
    // sort each of these in descending by start location
    for (var filePath in loc) {
        var refactorings_2 = loc[filePath];
        refactorings_2.sort(function (a, b) {
            return (b.span.start - a.span.start);
        });
    }
    return loc;
}
exports.getRefactoringsByFilePath = getRefactoringsByFilePath;
/**
 * For file listing we like to know if its a dir or file
 */
var FilePathType;
(function (FilePathType) {
    FilePathType[FilePathType["File"] = 0] = "File";
    FilePathType[FilePathType["Dir"] = 1] = "Dir";
})(FilePathType = exports.FilePathType || (exports.FilePathType = {}));
/** The JS file can only be in one of these states */
var JSOutputState;
(function (JSOutputState) {
    /** If emit skipped (Either emit is blocked or compiler options are noEmit) or perhaps there isn't a JS file emit for this (e.g .d.ts files) */
    JSOutputState[JSOutputState["NoJSFile"] = 1] = "NoJSFile";
    /** If JS file then its one of these */
    JSOutputState[JSOutputState["JSUpToDate"] = 2] = "JSUpToDate";
    JSOutputState[JSOutputState["JSOutOfDate"] = 3] = "JSOutOfDate";
})(JSOutputState = exports.JSOutputState || (exports.JSOutputState = {}));
/**
 * Complete related stuff
 */
/** Some constants */
exports.completionKindSnippet = "snippet";
exports.completionKindPath = "path";
/**
 * Errors
 */
var ErrorsDisplayMode;
(function (ErrorsDisplayMode) {
    ErrorsDisplayMode[ErrorsDisplayMode["all"] = 1] = "all";
    ErrorsDisplayMode[ErrorsDisplayMode["openFiles"] = 2] = "openFiles";
})(ErrorsDisplayMode = exports.ErrorsDisplayMode || (exports.ErrorsDisplayMode = {}));
/**
 * The TypeDoc icons a pretty expansive ðŸŒ¹ with a few ideas that I disagree with / or think are too difficult.
 * E.g the type `event`. The "grey" coloring of the global functions. The following is a simpler subset.
 *
 * Places that need to be kept in sync:
 * - typeIcon.tsx: the location in typeIcons.svg
 * - the legend component
 * - the server responses
 */
var IconType;
(function (IconType) {
    /**
     * There can be only one global
     * Any of the remaining things can be either in a module or global
     */
    IconType[IconType["Global"] = 0] = "Global";
    IconType[IconType["Namespace"] = 1] = "Namespace";
    IconType[IconType["Variable"] = 2] = "Variable";
    IconType[IconType["Function"] = 3] = "Function";
    IconType[IconType["FunctionGeneric"] = 4] = "FunctionGeneric";
    IconType[IconType["Enum"] = 5] = "Enum";
    IconType[IconType["EnumMember"] = 6] = "EnumMember";
    IconType[IconType["Interface"] = 7] = "Interface";
    IconType[IconType["InterfaceGeneric"] = 8] = "InterfaceGeneric";
    IconType[IconType["InterfaceConstructor"] = 9] = "InterfaceConstructor";
    IconType[IconType["InterfaceProperty"] = 10] = "InterfaceProperty";
    IconType[IconType["InterfaceMethod"] = 11] = "InterfaceMethod";
    IconType[IconType["InterfaceMethodGeneric"] = 12] = "InterfaceMethodGeneric";
    IconType[IconType["InterfaceIndexSignature"] = 13] = "InterfaceIndexSignature";
    IconType[IconType["Class"] = 14] = "Class";
    IconType[IconType["ClassGeneric"] = 15] = "ClassGeneric";
    IconType[IconType["ClassConstructor"] = 16] = "ClassConstructor";
    IconType[IconType["ClassProperty"] = 17] = "ClassProperty";
    IconType[IconType["ClassMethod"] = 18] = "ClassMethod";
    IconType[IconType["ClassMethodGeneric"] = 19] = "ClassMethodGeneric";
    IconType[IconType["ClassIndexSignature"] = 20] = "ClassIndexSignature";
})(IconType = exports.IconType || (exports.IconType = {}));
var UMLClassMemberVisibility;
(function (UMLClassMemberVisibility) {
    UMLClassMemberVisibility[UMLClassMemberVisibility["Public"] = 1] = "Public";
    UMLClassMemberVisibility[UMLClassMemberVisibility["Private"] = 2] = "Private";
    UMLClassMemberVisibility[UMLClassMemberVisibility["Protected"] = 3] = "Protected";
})(UMLClassMemberVisibility = exports.UMLClassMemberVisibility || (exports.UMLClassMemberVisibility = {}));
var UMLClassMemberLifetime;
(function (UMLClassMemberLifetime) {
    UMLClassMemberLifetime[UMLClassMemberLifetime["Instance"] = 1] = "Instance";
    UMLClassMemberLifetime[UMLClassMemberLifetime["Static"] = 2] = "Static";
})(UMLClassMemberLifetime = exports.UMLClassMemberLifetime || (exports.UMLClassMemberLifetime = {}));
/**
 * Tested
 */
var TestStatus;
(function (TestStatus) {
    TestStatus[TestStatus["NotRunYet"] = 1] = "NotRunYet";
    TestStatus[TestStatus["Fail"] = 2] = "Fail";
    TestStatus[TestStatus["Success"] = 3] = "Success";
    TestStatus[TestStatus["Skipped"] = 4] = "Skipped";
})(TestStatus = exports.TestStatus || (exports.TestStatus = {}));
/** Lots of things don't have a good error. But we would like to be consistent even with simple errors */
function makeBlandError(filePath, error, source) {
    return {
        source: source,
        filePath: filePath,
        from: {
            line: 0,
            ch: 0
        },
        to: {
            line: 0,
            ch: 0
        },
        message: error,
        preview: null,
        level: 'error'
    };
}
exports.makeBlandError = makeBlandError;
//////////////////////
// Live react demo
//////////////////////
exports.liveDemoMountUrl = '/demo';
